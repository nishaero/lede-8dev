--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -3453,6 +3453,10 @@ enum ieee80211_reconfig_type {
  * @del_nan_func: Remove a NAN function. The driver must call
  *	ieee80211_nan_func_terminated() with
  *	NL80211_NAN_FUNC_TERM_REASON_USER_REQUEST reason code upon removal.
+ * @mesh_ps_doze: Put the device to doze state now; schedule wakeup at given
+ *	TSF value (if non-zero). This callback is optional and may sleep.
+ * @mesh_ps_wakeup: Wake the device up now. This callback is optional and may
+ *	sleep.
  */
 struct ieee80211_ops {
 	void (*tx)(struct ieee80211_hw *hw,
@@ -3734,6 +3738,10 @@ struct ieee80211_ops {
 	void (*del_nan_func)(struct ieee80211_hw *hw,
 			    struct ieee80211_vif *vif,
 			    u8 instance_id);
+#ifdef CPTCFG_MAC80211_MESH
+	void (*mesh_ps_doze)(struct ieee80211_hw *hw, u64 nexttbtt);
+	void (*mesh_ps_wakeup)(struct ieee80211_hw *hw);
+#endif
 };
 
 /**
--- a/net/mac80211/driver-ops.h
+++ b/net/mac80211/driver-ops.h
@@ -1248,4 +1248,28 @@ static inline void drv_del_nan_func(stru
 	trace_drv_return_void(local);
 }
 
+#ifdef CPTCFG_MAC80211_MESH
+
+static inline void drv_mesh_ps_doze(struct ieee80211_local *local, u64 nexttbtt)
+{
+	might_sleep();
+
+	trace_drv_mesh_ps_doze(local, nexttbtt);
+	if (local->ops->mesh_ps_doze)
+		local->ops->mesh_ps_doze(&local->hw, nexttbtt);
+	trace_drv_return_void(local);
+}
+
+static inline void drv_mesh_ps_wakeup(struct ieee80211_local *local)
+{
+	might_sleep();
+
+	trace_drv_mesh_ps_wakeup(local);
+	if (local->ops->mesh_ps_wakeup)
+		local->ops->mesh_ps_wakeup(&local->hw);
+	trace_drv_return_void(local);
+}
+
+#endif
+
 #endif /* __MAC80211_DRIVER_OPS */
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -619,11 +619,10 @@ struct ieee80211_if_ocb {
  */
 struct ieee802_11_elems;
 struct ieee80211_mesh_sync_ops {
-	void (*rx_bcn_presp)(struct ieee80211_sub_if_data *sdata,
-			     u16 stype,
+	void (*rx_bcn_presp)(struct sta_info *sta,
 			     struct ieee80211_mgmt *mgmt,
 			     struct ieee802_11_elems *elems,
-			     struct ieee80211_rx_status *rx_status);
+			     u64 t_r);
 
 	/* should be called with beacon_data under RCU read lock */
 	void (*adjust_tsf)(struct ieee80211_sub_if_data *sdata,
@@ -695,6 +694,7 @@ struct ieee80211_if_mesh {
 	int ps_peers_light_sleep;
 	int ps_peers_deep_sleep;
 	struct ps_data ps;
+	struct timer_list awake_window_end_timer;
 	/* Channel Switching Support */
 	struct mesh_csa_settings __rcu *csa;
 	enum {
@@ -1353,7 +1353,7 @@ struct ieee80211_local {
 	bool pspolling;
 	bool offchannel_ps_enabled;
 	/*
-	 * PS can only be enabled when we have exactly one managed
+	 * managed mode PS can only be enabled when we have exactly one managed
 	 * interface (and monitors) in PS, this then points there.
 	 */
 	struct ieee80211_sub_if_data *ps_sdata;
@@ -1371,6 +1371,8 @@ struct ieee80211_local {
 
 	int user_power_level; /* in dBm, for all interfaces */
 	int user_antenna_gain; /* in dBi */
+	/* mesh power save can be enabled for multiple (but only mesh) vif */
+	bool mps_enabled;
 
 	enum ieee80211_smps_mode smps_mode;
 
--- a/net/mac80211/mesh.c
+++ b/net/mac80211/mesh.c
@@ -1054,6 +1054,7 @@ ieee80211_mesh_rx_probe_req(struct ieee8
 	memcpy(hdr->da, mgmt->sa, ETH_ALEN);
 	IEEE80211_SKB_CB(presp)->flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;
 	ieee80211_tx_skb(sdata, presp);
+	ieee80211_mps_awake_window_start(sdata);
 out:
 	rcu_read_unlock();
 }
@@ -1101,11 +1102,7 @@ static void ieee80211_mesh_rx_bcn_presp(
 		return;
 
 	if (mesh_matches_local(sdata, &elems))
-		mesh_neighbour_update(sdata, mgmt->sa, &elems);
-
-	if (ifmsh->sync_ops)
-		ifmsh->sync_ops->rx_bcn_presp(sdata,
-			stype, mgmt, &elems, rx_status);
+		mesh_neighbour_update(sdata, mgmt, &elems, rx_status);
 
 	if (ifmsh->csa_role != IEEE80211_MESH_CSA_ROLE_INIT &&
 	    !sdata->vif.csa_active)
@@ -1325,6 +1322,7 @@ static void mesh_bss_info_changed(struct
 void ieee80211_mesh_work(struct ieee80211_sub_if_data *sdata)
 {
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct ieee80211_local *local = sdata->local;
 
 	sdata_lock(sdata);
 
@@ -1348,6 +1346,12 @@ void ieee80211_mesh_work(struct ieee8021
 
 	if (test_and_clear_bit(MESH_WORK_MBSS_CHANGED, &ifmsh->wrkq_flags))
 		mesh_bss_info_changed(sdata);
+
+	if (test_and_clear_bit(MESH_WORK_PS_HW_CONF, &ifmsh->wrkq_flags))
+		ieee80211_mps_hw_conf(local);
+
+	if (test_and_clear_bit(MESH_WORK_PS_DOZE, &ifmsh->wrkq_flags))
+		ieee80211_mps_doze(local);
 out:
 	sdata_unlock(sdata);
 }
@@ -1380,6 +1384,9 @@ void ieee80211_mesh_init_sdata(struct ie
 	setup_timer(&ifmsh->mesh_path_root_timer,
 		    ieee80211_mesh_path_root_timer,
 		    (unsigned long) sdata);
+	setup_timer(&ifmsh->awake_window_end_timer,
+		    ieee80211_mps_awake_window_end,
+		    (unsigned long) sdata);
 	INIT_LIST_HEAD(&ifmsh->preq_queue.list);
 	skb_queue_head_init(&ifmsh->ps.bc_buf);
 	spin_lock_init(&ifmsh->mesh_preq_queue_lock);
--- a/net/mac80211/mesh.h
+++ b/net/mac80211/mesh.h
@@ -56,12 +56,16 @@ enum mesh_path_flags {
  * @MESH_WORK_DRIFT_ADJUST: time to compensate for clock drift relative to other
  * mesh nodes
  * @MESH_WORK_MBSS_CHANGED: rebuild beacon and notify driver of BSS changes
+ * @MESH_WORK_PS_HW_CONF: perform checks for PS mode and configure hardware
+ * @MESH_WORK_PS_DOZE: perform checks for doze state and put hardware to doze
  */
 enum mesh_deferred_task_flags {
 	MESH_WORK_HOUSEKEEPING,
 	MESH_WORK_ROOT,
 	MESH_WORK_DRIFT_ADJUST,
 	MESH_WORK_MBSS_CHANGED,
+	MESH_WORK_PS_HW_CONF,
+	MESH_WORK_PS_DOZE,
 };
 
 /**
@@ -242,6 +246,15 @@ void ieee80211_mpsp_trigger_process(u8 *
 				    bool tx, bool acked);
 void ieee80211_mps_frame_release(struct sta_info *sta,
 				 struct ieee802_11_elems *elems);
+void ieee80211_mps_hw_conf(struct ieee80211_local *local);
+void ieee80211_mps_sta_tbtt_update(struct sta_info *sta,
+				   struct ieee80211_mgmt *mgmt,
+				   const struct ieee80211_tim_ie *tim,
+				   u64 tsf);
+void ieee80211_mps_sta_tbtt_timeout(unsigned long data);
+void ieee80211_mps_awake_window_start(struct ieee80211_sub_if_data *sdata);
+void ieee80211_mps_awake_window_end(unsigned long data);
+void ieee80211_mps_doze(struct ieee80211_local *local);
 
 /* Mesh paths */
 int mesh_nexthop_lookup(struct ieee80211_sub_if_data *sdata,
@@ -272,7 +285,9 @@ int mesh_gate_num(struct ieee80211_sub_i
 
 /* Mesh plinks */
 void mesh_neighbour_update(struct ieee80211_sub_if_data *sdata,
-			   u8 *hw_addr, struct ieee802_11_elems *ie);
+			   struct ieee80211_mgmt *mgmt,
+			   struct ieee802_11_elems *ie,
+			   struct ieee80211_rx_status *rx_status);
 bool mesh_peer_accepts_plinks(struct ieee802_11_elems *ie);
 u32 mesh_accept_plinks_update(struct ieee80211_sub_if_data *sdata);
 void mesh_plink_broken(struct sta_info *sta);
--- a/net/mac80211/mesh_plink.c
+++ b/net/mac80211/mesh_plink.c
@@ -12,6 +12,7 @@
 #include "ieee80211_i.h"
 #include "rate.h"
 #include "mesh.h"
+#include "driver-ops.h"
 
 #define PLINK_CNF_AID(mgmt) ((mgmt)->u.action.u.self_prot.variable + 2)
 #define PLINK_GET_LLID(p) (p + 2)
@@ -561,29 +562,50 @@ mesh_sta_info_get(struct ieee80211_sub_i
  *
  * @sdata: local meshif
  * @addr: peer's address
- * @elems: IEs from beacon or mesh peering frame
+ * @elems: IEs from beacon or mesh probe response
  *
  * Initiates peering if appropriate.
  */
 void mesh_neighbour_update(struct ieee80211_sub_if_data *sdata,
-			   u8 *hw_addr,
-			   struct ieee802_11_elems *elems)
+			   struct ieee80211_mgmt *mgmt,
+			   struct ieee802_11_elems *elems,
+			   struct ieee80211_rx_status *rx_status)
 {
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;	
 	struct sta_info *sta;
 	u32 changed = 0;
+	u64 t_r;
+
+	/*
+	 * If available, calculate the time the beacon timestamp field was
+	 * received from the rx_status->mactime field. Otherwise get the
+	 * current TSF as approximation before entering rcu-read section.
+	 */
+	if (ieee80211_have_rx_timestamp(rx_status))
+		t_r = ieee80211_calculate_rx_timestamp(local, rx_status,
+				24 + 12 + elems->total_len + FCS_LEN, 24);
+	else
+		t_r = drv_get_tsf(local, sdata);
+
+	sta = mesh_sta_info_get(sdata, mgmt->sa, elems);
 
-	sta = mesh_sta_info_get(sdata, hw_addr, elems);
 	if (!sta)
 		goto out;
 
 	if (mesh_peer_accepts_plinks(elems) &&
 	    sta->mesh->plink_state == NL80211_PLINK_LISTEN &&
-	    sdata->u.mesh.accepting_plinks &&
-	    sdata->u.mesh.mshcfg.auto_open_plinks &&
+	    ifmsh->accepting_plinks && ifmsh->mshcfg.auto_open_plinks &&
 	    rssi_threshold_check(sdata, sta))
 		changed = mesh_plink_open(sta);
 
+	if (ifmsh->sync_ops)
+		ifmsh->sync_ops->rx_bcn_presp(sta, mgmt, elems, t_r);
+
 	ieee80211_mps_frame_release(sta, elems);
+
+	if (ieee80211_is_beacon(mgmt->frame_control))
+		ieee80211_mps_sta_tbtt_update(sta, mgmt, elems->tim, t_r);
 out:
 	rcu_read_unlock();
 	ieee80211_mbss_info_change_notify(sdata, changed);
--- a/net/mac80211/mesh_ps.c
+++ b/net/mac80211/mesh_ps.c
@@ -9,6 +9,16 @@
 
 #include "mesh.h"
 #include "wme.h"
+#include "driver-ops.h"
+
+#define BEACON_TIMEOUT	20000	/* in us units */
+
+static inline void mps_queue_work(struct ieee80211_sub_if_data *sdata,
+				 enum mesh_deferred_task_flags flag)
+{
+	set_bit(flag, &sdata->u.mesh.wrkq_flags);
+	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
+}
 
 
 /* mesh PS management */
@@ -138,6 +148,8 @@ u32 ieee80211_mps_local_status_update(st
 	ifmsh->ps_peers_light_sleep = light_sleep_cnt;
 	ifmsh->ps_peers_deep_sleep = deep_sleep_cnt;
 
+	mps_queue_work(sdata, MESH_WORK_PS_HW_CONF);
+
 	return changed;
 }
 
@@ -337,6 +349,8 @@ static void mps_set_sta_nonpeer_pm(struc
 void ieee80211_mps_rx_h_sta_process(struct sta_info *sta,
 				    struct ieee80211_hdr *hdr)
 {
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	
 	if (is_unicast_ether_addr(hdr->addr1) &&
 	    ieee80211_is_data_qos(hdr->frame_control)) {
 		/*
@@ -354,6 +368,13 @@ void ieee80211_mps_rx_h_sta_process(stru
 		 * (see IEEE802.11-2012 8.2.4.1.7)
 		 */
 		mps_set_sta_nonpeer_pm(sta, hdr);
+
+		/* resume doze after multicast receipt */
+		if (sdata->local->mps_enabled &&
+		    is_multicast_ether_addr(hdr->addr1) &&
+		    !ieee80211_has_moredata(hdr->frame_control) &&
+		    test_and_clear_sta_flag(sta, WLAN_STA_MPS_WAIT_FOR_CAB))
+			mps_queue_work(sdata, MESH_WORK_PS_DOZE);
 	}
 }
 
@@ -536,6 +557,7 @@ static void mps_frame_deliver(struct sta
 void ieee80211_mpsp_trigger_process(u8 *qc, struct sta_info *sta,
 				    bool tx, bool acked)
 {
+	struct ieee80211_local *local = sta->sdata->local;
 	u8 rspi = qc[1] & (IEEE80211_QOS_CTL_RSPI >> 8);
 	u8 eosp = qc[0] & IEEE80211_QOS_CTL_EOSP;
 
@@ -558,6 +580,15 @@ void ieee80211_mpsp_trigger_process(u8 *
 		if (rspi && !test_and_set_sta_flag(sta, WLAN_STA_MPSP_OWNER))
 			mps_frame_deliver(sta, -1);
 	}
+	
+	if (!local->mps_enabled)
+		return;
+
+	if (test_sta_flag(sta, WLAN_STA_MPSP_OWNER) ||
+	    test_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT))
+		drv_mesh_ps_wakeup(local);
+	else
+		mps_queue_work(sta->sdata, MESH_WORK_PS_DOZE);
 }
 
 /**
@@ -603,3 +634,267 @@ void ieee80211_mps_frame_release(struct
 	else
 		mps_frame_deliver(sta, 1);
 }
+
+/* mesh PS driver configuration and doze scheduling */
+
+static bool mps_hw_conf_check(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+	struct ieee80211_if_mesh *ifmsh;
+	bool enable = true;
+
+	if (!local->ops->mesh_ps_doze ||
+	    !local->ops->mesh_ps_wakeup)
+		return false;
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		/* disallow PS if an AP or any other non-mesh vif is found */
+		if (ieee80211_sdata_running(sdata) &&
+		    sdata->vif.type != NL80211_IFTYPE_MESH_POINT) {
+			enable = false;
+			break;
+		}
+
+		ifmsh = &sdata->u.mesh;
+
+		/*
+		 * Check for non-peer power mode and links in active mode.
+		 * Assume a valid power mode for each established peer link.
+		 */
+		if (ifmsh->nonpeer_pm == NL80211_MESH_POWER_ACTIVE ||
+		    ifmsh->ps_peers_light_sleep + ifmsh->ps_peers_deep_sleep
+				< atomic_read(&ifmsh->estab_plinks)) {
+			enable = false;
+			break;
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	return enable;
+}
+
+/**
+ * ieee80211_mps_hw_conf - check conditions for mesh PS and configure driver
+ *
+ * @local: mac80211 hw info struct
+ */
+void ieee80211_mps_hw_conf(struct ieee80211_local *local)
+{
+	bool enable;
+
+	enable = mps_hw_conf_check(local);
+
+	if (local->mps_enabled == enable)
+		return;
+
+	if (enable)
+		local->hw.conf.flags |= IEEE80211_CONF_PS;
+	else
+		local->hw.conf.flags &= ~IEEE80211_CONF_PS;
+
+	ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_PS);
+	local->mps_enabled = enable;
+
+	/* receive all peer beacons once before doze */
+	if (enable)
+		drv_mesh_ps_wakeup(local);
+}
+
+static void mps_sta_nexttbtt_calc(struct sta_info *sta,
+				  const struct ieee80211_tim_ie *tim,
+				  u64 tsf_local)
+{
+	u64 tsf_peer;
+	int skip = 1;
+	u32 nexttbtt_interval;
+
+	/* simple Deep Sleep implementation: only wake up for DTIM beacons */
+	if (tim && sta->mesh->local_pm == NL80211_MESH_POWER_DEEP_SLEEP)
+		skip = tim->dtim_count ? tim->dtim_count : tim->dtim_period;
+	/*
+	 * determine time to peer TBTT (TSF % beacon_interval = 0).
+	 * This approach is robust to delayed beacons.
+	 */
+	tsf_peer = tsf_local + sta->mesh->t_offset;
+	nexttbtt_interval = sta->mesh->beacon_interval * skip -
+			do_div(tsf_peer, sta->mesh->beacon_interval * skip);
+
+	mps_dbg(sta->sdata, "updating %pM next TBTT in %dus (%lldus awake)\n",
+		sta->sta.addr, nexttbtt_interval,
+		(long long) tsf_local - sta->mesh->nexttbtt_tsf);
+
+	sta->mesh->nexttbtt_tsf = tsf_local + nexttbtt_interval;
+	sta->mesh->nexttbtt_jiffies = jiffies + usecs_to_jiffies(nexttbtt_interval);
+	mod_timer(&sta->mesh->nexttbtt_timer, sta->mesh->nexttbtt_jiffies +
+			usecs_to_jiffies(BEACON_TIMEOUT));
+}
+
+/**
+ * ieee80211_mps_sta_tbtt_update - update peer beacon wakeup schedule
+ *
+ * @sta: mesh STA
+ * @mgmt: beacon frame
+ * @tim: TIM IE of beacon frame
+ * @tsf_local: current HW TSF
+ */
+void ieee80211_mps_sta_tbtt_update(struct sta_info *sta,
+				   struct ieee80211_mgmt *mgmt,
+				   const struct ieee80211_tim_ie *tim,
+				   u64 tsf_local)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	if (!sdata->local->mps_enabled ||
+	    sta->mesh->plink_state != NL80211_PLINK_ESTAB)
+		return;
+
+	sta->mesh->beacon_interval = ieee80211_tu_to_usec(
+			le16_to_cpu(mgmt->u.beacon.beacon_int));
+	if (tim && tim->bitmap_ctrl & 0x01) /* multicasts after DTIM? */
+		set_sta_flag(sta, WLAN_STA_MPS_WAIT_FOR_CAB);
+	else
+		clear_sta_flag(sta, WLAN_STA_MPS_WAIT_FOR_CAB);
+
+	mps_sta_nexttbtt_calc(sta, tim, tsf_local);
+
+	mps_queue_work(sdata, MESH_WORK_PS_DOZE);
+}
+
+/**
+ * ieee80211_mps_sta_tbtt_timeout - timer callback for missed peer beacons
+ */
+void ieee80211_mps_sta_tbtt_timeout(unsigned long data)
+{
+	struct sta_info *sta = (void *) data;
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+
+	spin_lock_bh(&sta->lock);
+
+	if (!sdata->local->mps_enabled ||
+	    sta->mesh->plink_state != NL80211_PLINK_ESTAB) {
+		spin_unlock_bh(&sta->lock);
+		return;
+	}
+
+	sta->mesh->nexttbtt_tsf += sta->mesh->beacon_interval;
+	sta->mesh->nexttbtt_jiffies += usecs_to_jiffies(sta->mesh->beacon_interval);
+	mod_timer(&sta->mesh->nexttbtt_timer, sta->mesh->nexttbtt_jiffies +
+			usecs_to_jiffies(BEACON_TIMEOUT));
+	mps_queue_work(sdata, MESH_WORK_PS_DOZE);
+	mps_dbg(sdata, "beacon miss %pM\n", sta->sta.addr);
+
+	spin_unlock_bh(&sta->lock);
+}
+
+/**
+ * ieee80211_mps_awake_window_start - start Awake Window on SWBA/PRETBTT
+ *
+ * @sdata: local mesh subif
+ *
+ * TODO called from ieee80211_beacon_get_tim as time reference for TBTT,
+ * but mac80211 API guarantees neither exact timing nor periodicity
+ */
+void ieee80211_mps_awake_window_start(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_local *local = sdata->local;
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	unsigned long timeout;
+
+	if (!local->mps_enabled)
+		return;
+
+	mps_dbg(sdata, "awake window start (%dTU)\n",
+		ifmsh->mshcfg.dot11MeshAwakeWindowDuration);
+
+	timeout = jiffies + usecs_to_jiffies(ieee80211_tu_to_usec(
+			ifmsh->mshcfg.dot11MeshAwakeWindowDuration));
+	mod_timer(&ifmsh->awake_window_end_timer, timeout);
+
+	drv_mesh_ps_wakeup(local);
+}
+
+/**
+ * ieee80211_mps_awake_window_end - timer callback for end of Awake Window
+ */
+void ieee80211_mps_awake_window_end(unsigned long data)
+{
+	struct ieee80211_sub_if_data *sdata = (void *) data;
+
+	if (!sdata->local->mps_enabled)
+		return;
+
+	mps_dbg(sdata, "awake window end\n");
+	mps_queue_work(sdata, MESH_WORK_PS_DOZE);
+}
+
+static bool mps_doze_check_vif(struct ieee80211_local *local)
+{
+	struct ieee80211_sub_if_data *sdata;
+	bool allow = true;
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!ieee80211_sdata_running(sdata))
+			continue;
+
+		if (!ieee80211_vif_is_mesh(&sdata->vif) ||
+		    timer_pending(&sdata->u.mesh.awake_window_end_timer)) {
+			allow = false;
+			break;
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	return allow;
+}
+
+static bool mps_doze_check_sta(struct ieee80211_local *local, u64 *nexttbtt)
+{
+	struct sta_info *sta;
+	bool allow = true;
+	u64 nexttbtt_min = ULLONG_MAX;
+
+	mutex_lock(&local->sta_mtx);
+	list_for_each_entry(sta, &local->sta_list, list) {
+		if (!ieee80211_vif_is_mesh(&sta->sdata->vif) ||
+		    !ieee80211_sdata_running(sta->sdata) ||
+		    sta->mesh->plink_state != NL80211_PLINK_ESTAB) {
+			continue;
+		} else if (test_sta_flag(sta, WLAN_STA_MPS_WAIT_FOR_CAB) ||
+			   test_sta_flag(sta, WLAN_STA_MPSP_OWNER) ||
+			   test_sta_flag(sta, WLAN_STA_MPSP_RECIPIENT) ||
+			   !timer_pending(&sta->mesh->nexttbtt_timer) ||
+			   time_after(jiffies, sta->mesh->nexttbtt_jiffies)) {
+			allow = false;
+			break;
+		} else if (sta->mesh->nexttbtt_tsf < nexttbtt_min) {
+			nexttbtt_min = sta->mesh->nexttbtt_tsf;
+		}
+	}
+	mutex_unlock(&local->sta_mtx);
+
+	*nexttbtt = (nexttbtt_min != ULLONG_MAX ? nexttbtt_min : 0);
+
+	return allow;
+}
+
+/**
+ * ieee80211_mps_doze - trigger radio doze state after checking conditions
+ *
+ * @local: mac80211 hw info struct
+ */
+void ieee80211_mps_doze(struct ieee80211_local *local)
+{
+	u64 nexttbtt;
+
+	if (!local->mps_enabled ||
+	    !mps_doze_check_vif(local) ||
+	    !mps_doze_check_sta(local, &nexttbtt))
+		return;
+
+	drv_mesh_ps_doze(local, nexttbtt);
+}
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -333,6 +333,9 @@ struct sta_info *sta_info_alloc(struct i
 		    !sdata->u.mesh.user_mpm)
 			init_timer(&sta->mesh->plink_timer);
 		sta->mesh->nonpeer_pm = NL80211_MESH_POWER_ACTIVE;
+		setup_timer(&sta->nexttbtt_timer,
+			    ieee80211_mps_sta_tbtt_timeout,
+			    (unsigned long) sta);
 	}
 #endif
 
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -72,6 +72,7 @@
  *	until pending frames are delivered
  *
  * @NUM_WLAN_STA_FLAGS: number of defined flags
+ * @WLAN_STA_MPS_WAIT_FOR_CAB: multicast frames from this STA are imminent.
  */
 enum ieee80211_sta_info_flags {
 	WLAN_STA_AUTH,
@@ -100,6 +101,7 @@ enum ieee80211_sta_info_flags {
 	WLAN_STA_MPSP_OWNER,
 	WLAN_STA_MPSP_RECIPIENT,
 	WLAN_STA_PS_DELIVER,
+	WLAN_STA_MPS_WAIT_FOR_CAB,
 
 	NUM_WLAN_STA_FLAGS,
 };
@@ -341,6 +343,10 @@ struct ieee80211_fast_rx {
  * @nonpeer_pm: STA power save mode towards non-peer neighbors
  * @processed_beacon: set to true after peer rates and capabilities are
  *	processed
+ * @beacon_interval: beacon interval of neighbor STA (in us)
+ * @nexttbtt_tsf: next TBTT in local TSF units
+ * @nexttbtt_jiffies: next TBTT in jiffies units
+ * @nexttbtt_timer: timeout for missed beacons
  * @fail_avg: moving percentage of failed MSDUs
  */
 struct mesh_sta {
@@ -365,6 +371,11 @@ struct mesh_sta {
 	enum nl80211_mesh_power_mode local_pm;
 	enum nl80211_mesh_power_mode peer_pm;
 	enum nl80211_mesh_power_mode nonpeer_pm;
+	u32 beacon_interval;
+	u64 nexttbtt_tsf;
+	unsigned long nexttbtt_jiffies;
+	struct timer_list nexttbtt_timer;
+
 
 	/* moving percentage of failed MSDUs */
 	unsigned int fail_avg;
@@ -428,6 +439,7 @@ struct ieee80211_sta_rx_stats {
  * @ampdu_mlme: A-MPDU state machine state
  * @timer_to_tid: identity mapping to ID timers
  * @mesh: mesh STA information
+ * @debugfs: debug filesystem info
  * @debugfs_dir: debug filesystem directory dentry
  * @dead: set to true when sta is unlinked
  * @removed: set to true when sta is being removed from sta_list
@@ -471,6 +483,12 @@ struct sta_info {
 	struct ieee80211_fast_rx __rcu *fast_rx;
 	struct ieee80211_sta_rx_stats __percpu *pcpu_rx_stats;
 
+	u32 beacon_interval;
+	u64 nexttbtt_tsf;
+	unsigned long nexttbtt_jiffies;
+	struct timer_list nexttbtt_timer;
+
+
 #ifdef CPTCFG_MAC80211_MESH
 	struct mesh_sta *mesh;
 #endif
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -1708,6 +1708,36 @@ DEFINE_EVENT(local_sdata_evt, drv_leave_
 	TP_ARGS(local, sdata)
 );
 
+#ifdef CPTCFG_MAC80211_MESH
+
+TRACE_EVENT(drv_mesh_ps_doze,
+	TP_PROTO(struct ieee80211_local *local, u64 nexttbtt),
+
+	TP_ARGS(local, nexttbtt),
+
+	TP_STRUCT__entry(
+		LOCAL_ENTRY
+		__field(u64, nexttbtt)
+	),
+
+	TP_fast_assign(
+		LOCAL_ASSIGN;
+		__entry->nexttbtt = nexttbtt;
+	),
+
+	TP_printk(
+		LOCAL_PR_FMT " nexttbtt:%llu",
+		LOCAL_PR_ARG, (unsigned long long)__entry->nexttbtt
+	)
+);
+
+DEFINE_EVENT(local_only_evt, drv_mesh_ps_wakeup,
+	TP_PROTO(struct ieee80211_local *local),
+	TP_ARGS(local)
+);
+
+#endif
+
 TRACE_EVENT(drv_get_expected_throughput,
 	TP_PROTO(struct ieee80211_sta *sta),
 
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -4226,6 +4226,8 @@ __ieee80211_beacon_get(struct ieee80211_
 
 		memcpy(skb_put(skb, beacon->tail_len), beacon->tail,
 		       beacon->tail_len);
+
+		ieee80211_mps_awake_window_start(sdata);
 	} else {
 		WARN_ON(1);
 		goto out;
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@ -79,6 +79,7 @@ static const char * const sta_flag_names
 	FLAG(TOFFSET_KNOWN),
 	FLAG(MPSP_OWNER),
 	FLAG(MPSP_RECIPIENT),
+	FLAG(MPS_WAIT_FOR_CAB),
 	FLAG(PS_DELIVER),
 #undef FLAG
 };
--- a/net/mac80211/mesh_sync.c
+++ b/net/mac80211/mesh_sync.c
@@ -79,43 +79,17 @@ void mesh_sync_adjust_tsf(struct ieee802
 	}
 }
 
-static void mesh_sync_offset_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,
-				   u16 stype,
-				   struct ieee80211_mgmt *mgmt,
-				   struct ieee802_11_elems *elems,
-				   struct ieee80211_rx_status *rx_status)
+static void mesh_sync_offset_rx_bcn_presp(struct sta_info *sta,
+					  struct ieee80211_mgmt *mgmt,
+					  struct ieee802_11_elems *elems,
+					  u64 t_r)
 {
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
 	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
-	struct ieee80211_local *local = sdata->local;
-	struct sta_info *sta;
-	u64 t_t, t_r;
+	u64 t_t;
 
 	WARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);
 
-	/* standard mentions only beacons */
-	if (stype != IEEE80211_STYPE_BEACON)
-		return;
-
-	/*
-	 * Get time when timestamp field was received.  If we don't
-	 * have rx timestamps, then use current tsf as an approximation.
-	 * drv_get_tsf() must be called before entering the rcu-read
-	 * section.
-	 */
-	if (ieee80211_have_rx_timestamp(rx_status))
-		t_r = ieee80211_calculate_rx_timestamp(local, rx_status,
-						       24 + 12 +
-						       elems->total_len +
-						       FCS_LEN,
-						       24);
-	else
-		t_r = drv_get_tsf(local, sdata);
-
-	rcu_read_lock();
-	sta = sta_info_get(sdata, mgmt->sa);
-	if (!sta)
-		goto no_sync;
-
 	/* check offset sync conditions (13.13.2.2.1)
 	 *
 	 * TODO also sync to
@@ -125,7 +99,7 @@ static void mesh_sync_offset_rx_bcn_pres
 	if (elems->mesh_config && mesh_peer_tbtt_adjusting(elems)) {
 		msync_dbg(sdata, "STA %pM : is adjusting TBTT\n",
 			  sta->sta.addr);
-		goto no_sync;
+		return;
 	}
 
 	/* Timing offset calculation (see 13.13.2.2.2) */
@@ -147,7 +121,7 @@ static void mesh_sync_offset_rx_bcn_pres
 				  sta->sta.addr,
 				  (long long) t_clockdrift);
 			clear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);
-			goto no_sync;
+			return;
 		}
 
 		spin_lock_bh(&ifmsh->sync_offset_lock);
@@ -162,9 +136,6 @@ static void mesh_sync_offset_rx_bcn_pres
 			  sta->sta.addr,
 			  (long long) sta->mesh->t_offset);
 	}
-
-no_sync:
-	rcu_read_unlock();
 }
 
 static void mesh_sync_offset_adjust_tsf(struct ieee80211_sub_if_data *sdata,
