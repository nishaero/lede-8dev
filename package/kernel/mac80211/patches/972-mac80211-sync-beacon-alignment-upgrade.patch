--- a/net/mac80211/mesh_sync.c
+++ b/net/mac80211/mesh_sync.c
@@ -59,12 +59,19 @@ void mesh_sync_adjust_tsf(struct ieee802
 	if (ifmsh->sync_offset_clockdrift_max < beacon_int_fraction) {
 		msync_dbg(sdata, "TSF : max clockdrift=%lld; adjusting\n",
 			  (long long) ifmsh->sync_offset_clockdrift_max);
+		/*Debug Messages*/
+		/*printk("MESH0: TSF : max clockdrift=%lld; adjusting\n",
+			  (long long) ifmsh->sync_offset_clockdrift_max);*/
 		tsfdelta = -ifmsh->sync_offset_clockdrift_max;
 		ifmsh->sync_offset_clockdrift_max = 0;
 	} else {
 		msync_dbg(sdata, "TSF : max clockdrift=%lld; adjusting by %llu\n",
 			  (long long) ifmsh->sync_offset_clockdrift_max,
 			  (unsigned long long) beacon_int_fraction);
+		/*Debug messages*/
+		/*printk("MESH0: TSF : max clockdrift=%lld; adjusting by %llu\n",
+			  (long long) ifmsh->sync_offset_clockdrift_max,
+			  (unsigned long long) beacon_int_fraction);*/
 		tsfdelta = -beacon_int_fraction;
 		ifmsh->sync_offset_clockdrift_max -= beacon_int_fraction;
 	}
@@ -99,11 +106,16 @@ static void mesh_sync_offset_rx_bcn_pres
 	if (elems->mesh_config && mesh_peer_tbtt_adjusting(elems)) {
 		msync_dbg(sdata, "STA %pM : is adjusting TBTT\n",
 			  sta->sta.addr);
+		/*Debug messages*/
+		/*printk("MESH0: STA %pM : is adjusting TBTT\n",
+			  sta->sta.addr);*/
 		return;
 	}
 
 	/* Timing offset calculation (see 13.13.2.2.2) */
 	t_t = le64_to_cpu(mgmt->u.beacon.timestamp);
+	/*Debug Messages*/
+	/*printk("MESH0: t_t value :=%lld, t-r value= %lld, t_offsett value=%lld\n",t_t,t_r, t_t-t_r);*/
 	sta->mesh->t_offset = t_t - t_r;
 
 	if (test_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN)) {
@@ -113,13 +125,21 @@ static void mesh_sync_offset_rx_bcn_pres
 			  sta->sta.addr, (long long) sta->mesh->t_offset,
 			  (long long) sta->mesh->t_offset_setpoint,
 			  (long long) t_clockdrift);
-
+		/*Debug messages*/
+		/*printk("MESH0: STA %pM : t_offset=%lld, t_offset_setpoint=%lld, t_clockdrift=%lld\n",
+			  sta->sta.addr, (long long) sta->mesh->t_offset,
+			  (long long) sta->mesh->t_offset_setpoint,
+			  (long long) t_clockdrift);*/
 		if (t_clockdrift > TOFFSET_MAXIMUM_ADJUSTMENT ||
 		    t_clockdrift < -TOFFSET_MAXIMUM_ADJUSTMENT) {
 			msync_dbg(sdata,
 				  "STA %pM : t_clockdrift=%lld too large, setpoint reset\n",
 				  sta->sta.addr,
 				  (long long) t_clockdrift);
+			/*Debug Messages*/
+			/*printk("MESH0: STA %pM : t_clockdrift=%lld too large, setpoint reset\n",
+				  sta->sta.addr,
+				  (long long) t_clockdrift);*/
 			clear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);
 			return;
 		}
@@ -135,6 +155,10 @@ static void mesh_sync_offset_rx_bcn_pres
 			  "STA %pM : offset was invalid, t_offset=%lld\n",
 			  sta->sta.addr,
 			  (long long) sta->mesh->t_offset);
+		/*Debug Messages*/
+		/*printk("MESH0: STA %pM : offset was invalid, t_offset=%lld\n",
+			  sta->sta.addr,
+			  (long long) sta->mesh->t_offset);*/
 	}
 }
 
@@ -157,16 +181,188 @@ static void mesh_sync_offset_adjust_tsf(
 		msync_dbg(sdata,
 			  "TSF : kicking off TSF adjustment with clockdrift_max=%lld\n",
 			  ifmsh->sync_offset_clockdrift_max);
+		/*Debug Printk statements*/
+		/*printk("MESH0: TSF : kicking off TSF adjustment with clockdrift_max=%lld\n",
+			  ifmsh->sync_offset_clockdrift_max);*/
 		set_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags);
 	} else {
 		msync_dbg(sdata,
 			  "TSF : max clockdrift=%lld; too small to adjust\n",
 			  (long long)ifmsh->sync_offset_clockdrift_max);
+		/*Debug Printk statements*/
+		/*printk("MESH0: TSF : max clockdrift=%lld; too small to adjust\n",
+			  (long long)ifmsh->sync_offset_clockdrift_max);*/
 		ifmsh->sync_offset_clockdrift_max = 0;
 	}
 	spin_unlock_bh(&ifmsh->sync_offset_lock);
 }
 
+static void mesh_sync_align_rx_bcn_presp(struct sta_info *sta,
+					 struct ieee80211_mgmt *mgmt,
+					 struct ieee802_11_elems *elems,
+					 u64 t_r)
+{
+	sta->mesh->beacon_interval = ieee80211_tu_to_usec(le16_to_cpu(
+			mgmt->u.beacon.beacon_int));
+
+	/* Timing offset calculation (see 13.13.2.2.2) */
+	sta->mesh->t_offset = le64_to_cpu(mgmt->u.beacon.timestamp) - t_r;
+}
+
+static inline int tbtt_offset_get(s64 t_offset, u32 bi_min)
+{
+	u32 offset;
+	/*u64 tmp = abs64(t_offset);*/
+	u64 tmp = abs(t_offset);
+
+	/*Debug Prink K remove me*/
+	/*printk("MESH0: t_offset on abs values of abs: %lld\n", abs(t_offset));*/
+
+	/* do_div only for unsigned values */
+	offset = do_div(tmp, bi_min);
+
+	/* invert positive offsets to get the offset towards later TBTT */
+	if (t_offset >= 0)
+		return  offset - bi_min;
+	else
+		return -offset;
+}
+
+static inline int tbtt_offset_get_local(struct ieee80211_sub_if_data *sdata, struct sta_info *sta)
+{
+	return tbtt_offset_get(sta->mesh->t_offset,
+			       min((u32)ieee80211_tu_to_usec(
+					sta->sdata->vif.bss_conf.beacon_int),
+					sta->mesh->beacon_interval));
+}
+
+static inline int tbtt_offset_get_local_inv(struct sta_info *sta, struct ieee80211_sub_if_data *sdata)
+{
+	return tbtt_offset_get(-sta->mesh->t_offset,
+			       min((u32)ieee80211_tu_to_usec(
+					sta->sdata->vif.bss_conf.beacon_int),
+					sta->mesh->beacon_interval));
+}
+
+static inline int tbtt_offset_get_sta(struct sta_info *staa, struct sta_info *stab)
+{
+	return tbtt_offset_get(stab->mesh->t_offset - staa->mesh->t_offset,
+			       min(staa->mesh->beacon_interval,
+				   stab->mesh->beacon_interval));
+}
+
+/*
+ * get offset of STA to its next peer (or local STA) TBTT
+ */
+static int sta_offset_min_get(struct ieee80211_sub_if_data *sdata, struct sta_info *staa)
+{
+	struct sta_info *stab;
+	int offset_min = INT_MIN, offset;
+	struct sta_info *sta_next = NULL;
+
+	/* STA - peer STA */
+	list_for_each_entry(stab, &sdata->local->sta_list, list) {
+		if (!ieee80211_vif_is_mesh(&stab->sdata->vif) ||
+		    !ieee80211_sdata_running(stab->sdata) ||
+		    stab->mesh->plink_state != NL80211_PLINK_ESTAB ||
+		    staa == stab)
+			continue;
+
+		offset = tbtt_offset_get_sta(staa, stab);
+		if (offset > offset_min) {
+			offset_min = offset;
+			sta_next = stab;
+		}
+	}
+
+	/* STA - local STA */
+	offset = tbtt_offset_get_local_inv(staa, sdata);
+	if (offset > offset_min) {
+		offset_min = offset;
+		msync_dbg(sdata, "offset %pM - local STA %dus\n",
+			  staa->sta.addr, offset_min);
+		/*Debug Messages*/
+		/*printk("MESH0: offset %pM - local STA %dus\n",
+			  staa->sta.addr, offset_min);*/
+	} else if (sta_next) {
+		msync_dbg(sdata, "offset %pM - %pM %dus\n",
+			  staa->sta.addr, sta_next->sta.addr, offset_min);
+		/*Debug Messages*/
+		/*printk("MESH0: offset %pM - %pM %dus\n",
+			  staa->sta.addr, sta_next->sta.addr, offset_min);*/
+	}
+
+	return offset_min;
+}
+
+static void mesh_sync_align_adjust_tsf(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_if_mesh *ifmsh = &sdata->u.mesh;
+	struct sta_info *sta;
+	int peer_offset_max = INT_MAX, local_offset_min = INT_MIN, offset;
+	struct sta_info *sta_steady = NULL, *sta_next = NULL;
+
+	WARN_ON(ifmsh->mesh_sp_id != IEEE80211_SYNC_METHOD_VENDOR);
+	BUG_ON(!rcu_read_lock_held());
+
+	/*
+	 * NOTE:
+	 * We only look for TBTT offsets to peer's TBTT later than ours. These
+	 * are always negative (like t_offset). Thus, all following comparisons
+	 * are inverse.
+	 */
+
+	list_for_each_entry(sta, &sdata->local->sta_list, list) {
+		if (!ieee80211_vif_is_mesh(&sta->sdata->vif) ||
+		    !ieee80211_sdata_running(sta->sdata) ||
+		    sta->mesh->plink_state != NL80211_PLINK_ESTAB)
+			continue;
+
+		/* peer STA - others (including local STA) */
+		offset = sta_offset_min_get(sdata, sta);
+		if (offset < peer_offset_max) {
+			peer_offset_max = offset;
+			sta_steady = sta;
+		}
+
+		/* local STA - peer STA */
+		offset = tbtt_offset_get_local(sdata, sta);
+		if (offset > local_offset_min) {
+			local_offset_min = offset;
+			sta_next = sta;
+		}
+	}
+
+	if (sta_next)
+		msync_dbg(sdata, "offset local STA - %pM %dus\n",
+			  sta_next->sta.addr, local_offset_min);
+
+	if (local_offset_min < peer_offset_max) {
+		msync_dbg(sdata, "I am the steady node!\n");
+		ifmsh->adjusting_tbtt = false;
+	} else {
+		msync_dbg(sdata, "the steady node is %pM\n",
+			  sta_steady->sta.addr);
+		if (local_offset_min < -10000) {
+			msync_dbg(sdata, "adjusting towards %pM by %dus\n",
+				  sta_next->sta.addr, local_offset_min);
+			/*
+			 * Since adjusting the TSF here would
+			 * require a possibly blocking call
+			 * to the driver TSF setter, we punt
+			 * the TSF adjustment to the mesh tasklet
+			 */
+			ifmsh->sync_offset_clockdrift_max = -local_offset_min;
+			set_bit(MESH_WORK_DRIFT_ADJUST, &ifmsh->wrkq_flags);
+			ifmsh->adjusting_tbtt = true;
+		} else {
+			ifmsh->adjusting_tbtt = false;
+		}
+	}
+}
+
+
+
 static const struct sync_method sync_methods[] = {
 	{
 		.method = IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET,
@@ -175,6 +371,13 @@ static const struct sync_method sync_met
 			.adjust_tsf = &mesh_sync_offset_adjust_tsf,
 		}
 	},
+	{
+		.method = IEEE80211_SYNC_METHOD_VENDOR,
+		.ops = {
+			.rx_bcn_presp = &mesh_sync_align_rx_bcn_presp,
+			.adjust_tsf = &mesh_sync_align_adjust_tsf,
+		}
+	},
 };
 
 const struct ieee80211_mesh_sync_ops *ieee80211_mesh_sync_ops_get(u8 method)
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -689,6 +689,7 @@ struct ieee80211_if_mesh {
 	const struct ieee80211_mesh_sync_ops *sync_ops;
 	s64 sync_offset_clockdrift_max;
 	spinlock_t sync_offset_lock;
+	bool adjusting_tbtt;
 	/* mesh power save */
 	enum nl80211_mesh_power_mode nonpeer_pm;
 	int ps_peers_light_sleep;
